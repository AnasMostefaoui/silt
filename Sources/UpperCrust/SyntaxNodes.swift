// SyntaxNodes.swift
// Automatically generated by SyntaxGen. Do not edit!
//
// Copyright 2017, The Silt Language Project.
//
// This project is released under the MIT license, a copy of which is
// available in the repository.
public class ExprSyntax: Syntax {}
class FuncApplicationExprSyntax: ExprSyntax {
  public enum Cursor: Int {
    case calleeExpr
    case arguments
  }

  public convenience init(calleeExpr: ExprSyntax, arguments: ExprListSyntax) {
    let raw = RawSyntax.node(.funcApplicationExpr, [
      calleeExpr.raw,
      arguments.raw,
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var calleeExpr: ExprSyntax {
    return child(at: Cursor.calleeExpr) as! ExprSyntax
  }
  public func withCalleeExpr(_ syntax: ExprSyntax) -> FuncApplicationExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.calleeExpr)
  }

  public var arguments: ExprListSyntax {
    return child(at: Cursor.arguments) as! ExprListSyntax
  }
  public func withArguments(_ syntax: ExprListSyntax) -> FuncApplicationExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.arguments)
  }

}

class LambdaExprSyntax: ExprSyntax {
  public enum Cursor: Int {
    case forwardSlashToken
    case parameterList
    case arrowToken
    case bodyExpr
  }

  public convenience init(forwardSlashToken: TokenSyntax, parameterList: ParameterListSyntax, arrowToken: TokenSyntax, bodyExpr: ExprSyntax) {
    let raw = RawSyntax.node(.lambdaExpr, [
      forwardSlashToken.raw,
      parameterList.raw,
      arrowToken.raw,
      bodyExpr.raw,
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var forwardSlashToken: TokenSyntax {
    return child(at: Cursor.forwardSlashToken) as! TokenSyntax
  }
  public func withForwardSlashToken(_ syntax: TokenSyntax) -> LambdaExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.forwardSlashToken)
  }

  public var parameterList: ParameterListSyntax {
    return child(at: Cursor.parameterList) as! ParameterListSyntax
  }
  public func withParameterList(_ syntax: ParameterListSyntax) -> LambdaExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.parameterList)
  }

  public var arrowToken: TokenSyntax {
    return child(at: Cursor.arrowToken) as! TokenSyntax
  }
  public func withArrowToken(_ syntax: TokenSyntax) -> LambdaExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.arrowToken)
  }

  public var bodyExpr: ExprSyntax {
    return child(at: Cursor.bodyExpr) as! ExprSyntax
  }
  public func withBodyExpr(_ syntax: ExprSyntax) -> LambdaExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.bodyExpr)
  }

}

class ParenExprSyntax: ExprSyntax {
  public enum Cursor: Int {
    case leftParenToken
    case expr
    case rightParenToken
  }

  public convenience init(leftParenToken: TokenSyntax, expr: ExprSyntax, rightParenToken: TokenSyntax) {
    let raw = RawSyntax.node(.parenExpr, [
      leftParenToken.raw,
      expr.raw,
      rightParenToken.raw,
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var leftParenToken: TokenSyntax {
    return child(at: Cursor.leftParenToken) as! TokenSyntax
  }
  public func withLeftParenToken(_ syntax: TokenSyntax) -> ParenExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.leftParenToken)
  }

  public var expr: ExprSyntax {
    return child(at: Cursor.expr) as! ExprSyntax
  }
  public func withExpr(_ syntax: ExprSyntax) -> ParenExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.expr)
  }

  public var rightParenToken: TokenSyntax {
    return child(at: Cursor.rightParenToken) as! TokenSyntax
  }
  public func withRightParenToken(_ syntax: TokenSyntax) -> ParenExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.rightParenToken)
  }

}

class IntegerLiteralExprSyntax: ExprSyntax {
  public enum Cursor: Int {
    case integerLiteral
  }

  public convenience init(integerLiteral: TokenSyntax) {
    let raw = RawSyntax.node(.integerLiteralExpr, [
      integerLiteral.raw,
    ], .present)
    let data = SyntaxData(raw: raw, parent: nil, indexInParent: 0)
    self.init(root: data, data: data)
  }
  public var integerLiteral: TokenSyntax {
    return child(at: Cursor.integerLiteral) as! TokenSyntax
  }
  public func withIntegerLiteral(_ syntax: TokenSyntax) -> IntegerLiteralExprSyntax {
    return data.replacingChild(syntax.raw, at: Cursor.integerLiteral)
  }

}

public class ParameterListSyntax: SyntaxCollection<TokenSyntax> {
  public override class var kind: SyntaxKind {
    return .parameterList
  }
}

public class ExprListSyntax: SyntaxCollection<ExprSyntax> {
  public override class var kind: SyntaxKind {
    return .exprList
  }
}

